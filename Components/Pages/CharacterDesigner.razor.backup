@page "/character"
@using TagbooruQuest.Models.CharacterDesigner
@using TagbooruQuest.Services.CharacterDesigner
@using TagbooruQuest.Data
@inject IDesignerRegistry DesignerRegistry
@inject ITagSpriteResolver SpriteResolver
@inject ICharacterBuildState BuildState
@inject TagbooruQuest.Data.TagGraphService TagGraphService
@inject IJSRuntime JSRuntime

<div class="character-designer">
    <!-- Group Tabs -->
    <div class="group-tabs">
        @foreach (var group in DesignerRegistry.Config.Groups)
        {
            <button class="group-tab @(activeGroupKey == group.Key ? "active" : "")"
                    @onclick="() => SetActiveGroup(group.Key)">
                @if (!string.IsNullOrEmpty(group.Icon))
                {
                    <span class="group-icon">@group.Icon</span>
                }
                <span class="group-title">@group.Title</span>
            </button>
        }
    </div>

    <!-- Panel Host -->
    <div class="panel-host">
        @if (activeGroup != null)
        {
            @foreach (var panel in activeGroup.Panels)
            {
                <div class="panel-card">
                    <div class="panel-header">
                        <h3 class="panel-title">@panel.Title</h3>
                        <div class="panel-selections">
                            @{
                                var selections = BuildState.GetSelections(panel.Key);
                            }
                            @if (selections.Any())
                            {
                                @if (panel.SelectionMode == SelectionMode.Single)
                                {
                                    var selection = selections.First();
                                    <div class="selected-preview">
                                        <img src="@selection.ImageUrl" alt="@selection.Display"
                                             onerror="this.src='/img/tagging_sprites/default.jpg'; this.onerror=null;" />
                                        <span class="selection-label">@selection.Display</span>
                                    </div>
                                }
                                else
                                {
                                    <span class="selection-count">@selections.Count selected</span>
                                }
                            }
                            else
                            {
                                <span class="no-selection">None selected</span>
                            }
                        </div>
                    </div>

                    @foreach (var source in panel.Sources)
                    {
                        <div class="source-row">
                            <div class="source-header">
                                <h4 class="source-title">@(source.Title ?? "Options")</h4>
                                <div class="source-header-controls">
                                    @{
                                        var sourceKey = GetSourceKey(panel.Key, source);
                                        var isMultiSelect = IsMultiSelectMode(sourceKey);
                                    }
                                    <button class="multi-select-toggle @(isMultiSelect ? "active" : "")"
                                            @onclick="() => ToggleMultiSelectMode(sourceKey)">
                                        Multi
                                    </button>
                                    <button class="expand-btn" @onclick="() => ToggleSourceExpanded(panel.Key, source)">
                                        @(IsSourceExpanded(panel.Key, source) ? "v" : ">")
                                    </button>
                                </div>
                            </div>

                            @if (IsSourceExpanded(panel.Key, source))
                            {
                                <div class="source-options" style="max-height: 200px; overflow-y: auto;">
                                    @{
                                        var sourceKey = GetSourceKey(panel.Key, source);
                                        var sourceOptions = GetCurrentSourceOptions(sourceKey);
                                        var breadcrumbs = GetNavigationBreadcrumbs(sourceKey);
                                        var isMultiSelect = IsMultiSelectMode(sourceKey);
                                    }

                                    @if (breadcrumbs.Count > 1)
                                    {
                                        <div class="navigation-dropdown">
                                            <div class="current-location">
                                                <span class="location-icon">ðŸ—‚</span>
                                                <span class="location-text">@breadcrumbs.Last().Display</span>
                                                <button class="dropdown-toggle" @onclick="() => ToggleNavigationDropdown(sourceKey)">
                                                    @(IsNavigationDropdownOpen(sourceKey) ? "^" : "v")
                                                </button>
                                            </div>

                                            @if (IsNavigationDropdownOpen(sourceKey))
                                            {
                                                <div class="dropdown-menu">
                                                    @for (int i = 0; i < breadcrumbs.Count; i++)
                                                    {
                                                        var breadcrumb = breadcrumbs[i];
                                                        var isLast = i == breadcrumbs.Count - 1;
                                                        var depth = i;

                                                        <button class="dropdown-item @(isLast ? "current" : "")"
                                                                style="padding-left: @((depth * 0.75 + 0.75)rem)"
                                                                @onclick="() => NavigateToDropdownItem(sourceKey, i)">
                                                            @if (depth > 0)
                                                            {
                                                                <span class="dropdown-indent">â”” </span>
                                                            }
                                                            @breadcrumb.Display
                                                            @if (isLast)
                                                            {
                                                                <span class="current-indicator">(current)</span>
                                                            }
                                                        </button>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    }

                                    @if (sourceOptions?.Any() == true)
                                    {
                                        <div class="tile-grid-inline">
                                            @foreach (var option in sourceOptions)
                                            {
                                                var isSelected = BuildState.GetSelections(panel.Key)
                                                    .Any(s => s.CanonicalTag == option.CanonicalTag);

                                                <div class="tile-inline @(isSelected ? "selected" : "") @(option.HasChildren ? "has-children" : "")"
                                                     @onclick="() => HandleOptionClick(panel, option, sourceKey)">
                                                    <img src="@option.ImageUrl" alt="@option.Display" loading="lazy" />
                                                    <span class="tile-label">@option.Display</span>
                                                    @if (option.HasChildren)
                                                    {
                                                        <span class="children-indicator">></span>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    }
                                    else
                                    {
                                        <div class="loading-options">Loading...</div>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
            }
        }
    </div>

    <!-- Prompt Bar -->
    <div class="prompt-bar">
        <div class="prompt-content">
            <div class="prompt-chips">
                @foreach (var selection in BuildState.GetAllSelections())
                {
                    <span class="prompt-chip">
                        @if (!string.IsNullOrEmpty(selection.GroupIcon))
                        {
                            <span class="chip-icon">@selection.GroupIcon</span>
                        }
                        @selection.Display
                    </span>
                }
            </div>
            <div class="prompt-actions">
                <button class="action-btn" @onclick="CopyPrompt">Copy</button>
                <button class="action-btn reset" @onclick="ResetSelections">Reset</button>
            </div>
        </div>
    </div>
</div>


@code {
    private string activeGroupKey = "hair"; // Updated to match new config
    private GroupConfig? activeGroup;
    private Dictionary<string, Dictionary<SourceConfig, bool>> expandedSources = new();
    private Dictionary<string, Dictionary<SourceConfig, List<TagOption>>> sourceOptionsCache = new();
    private Dictionary<string, List<NavigationBreadcrumb>> navigationState = new(); // Track navigation path for each source
    private Dictionary<string, bool> multiSelectMode = new(); // Track if source is in multi-select mode
    private Dictionary<string, bool> navigationDropdownOpen = new(); // Track dropdown open state

    public class NavigationBreadcrumb
    {
        public string Display { get; set; } = string.Empty;
        public int? NodeId { get; set; }
        public List<TagOption> Options { get; set; } = new();
    }

    protected override async Task OnInitializedAsync()
    {

        activeGroup = DesignerRegistry.GetGroup(activeGroupKey);

        BuildState.OnStateChanged += StateHasChanged;

        // Validate configuration in background
        _ = Task.Run(async () =>
        {
            try
            {
                await DesignerRegistry.ValidateConfigurationAsync();
            }
            catch (Exception ex)
            {
            }
        });
    }

    public void Dispose()
    {
        BuildState.OnStateChanged -= StateHasChanged;
    }

    private void SetActiveGroup(string groupKey)
    {
        activeGroupKey = groupKey;
        activeGroup = DesignerRegistry.GetGroup(groupKey);
        StateHasChanged();
    }

    private async Task ToggleSourceExpanded(string panelKey, SourceConfig source)
    {
        if (!expandedSources.ContainsKey(panelKey))
            expandedSources[panelKey] = new Dictionary<SourceConfig, bool>();

        var isExpanded = expandedSources[panelKey].ContainsKey(source) && expandedSources[panelKey][source];
        expandedSources[panelKey][source] = !isExpanded;

        if (!isExpanded && !HasCachedOptions(panelKey, source))
        {
            await LoadSourceOptions(panelKey, source);
        }

        StateHasChanged();
    }

    private bool IsSourceExpanded(string panelKey, SourceConfig source)
    {
        return expandedSources.ContainsKey(panelKey) &&
               expandedSources[panelKey].ContainsKey(source) &&
               expandedSources[panelKey][source];
    }

    private bool HasCachedOptions(string panelKey, SourceConfig source)
    {
        return sourceOptionsCache.ContainsKey(panelKey) &&
               sourceOptionsCache[panelKey].ContainsKey(source);
    }

    private List<TagOption>? GetSourceOptions(string panelKey, SourceConfig source)
    {
        if (sourceOptionsCache.ContainsKey(panelKey) &&
            sourceOptionsCache[panelKey].ContainsKey(source))
        {
            return sourceOptionsCache[panelKey][source];
        }
        return null;
    }

    private string GetSourceKey(string panelKey, SourceConfig source)
    {
        return $"{panelKey}_{source.GetHashCode()}";
    }

    private List<TagOption>? GetCurrentSourceOptions(string sourceKey)
    {
        var breadcrumbs = GetNavigationBreadcrumbs(sourceKey);
        return breadcrumbs.LastOrDefault()?.Options;
    }

    private List<NavigationBreadcrumb> GetNavigationBreadcrumbs(string sourceKey)
    {
        return navigationState.ContainsKey(sourceKey) ? navigationState[sourceKey] : new List<NavigationBreadcrumb>();
    }

    private bool IsMultiSelectMode(string sourceKey)
    {
        return multiSelectMode.ContainsKey(sourceKey) && multiSelectMode[sourceKey];
    }

    private void ToggleMultiSelectMode(string sourceKey)
    {
        multiSelectMode[sourceKey] = !IsMultiSelectMode(sourceKey);
        StateHasChanged();
    }

    private async Task HandleOptionClick(PanelConfig panel, TagOption option, string sourceKey)
    {
        if (option.HasChildren)
        {
            await NavigateToChildren(sourceKey, option);
        }
        else
        {
            SelectOption(panel, option);
        }
    }

    private async Task NavigateToChildren(string sourceKey, TagOption parentOption)
    {
        try
        {
            var childOptions = await LoadChildOptions(parentOption);

            // Add new breadcrumb level
            if (!navigationState.ContainsKey(sourceKey))
                navigationState[sourceKey] = new List<NavigationBreadcrumb>();

            navigationState[sourceKey].Add(new NavigationBreadcrumb
            {
                Display = parentOption.Display,
                NodeId = parentOption.NodeId,
                Options = childOptions
            });

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error navigating to children: {ex.Message}");
        }
    }

    private void ToggleNavigationDropdown(string sourceKey)
    {
        navigationDropdownOpen[sourceKey] = !IsNavigationDropdownOpen(sourceKey);
        StateHasChanged();
    }

    private bool IsNavigationDropdownOpen(string sourceKey)
    {
        return navigationDropdownOpen.ContainsKey(sourceKey) && navigationDropdownOpen[sourceKey];
    }

    private void NavigateToDropdownItem(string sourceKey, int breadcrumbIndex)
    {
        if (!navigationState.ContainsKey(sourceKey)) return;

        var breadcrumbs = navigationState[sourceKey];
        if (breadcrumbIndex < breadcrumbs.Count)
        {
            // Remove all breadcrumbs after the clicked one
            navigationState[sourceKey] = breadcrumbs.Take(breadcrumbIndex + 1).ToList();

            // Close the dropdown
            navigationDropdownOpen[sourceKey] = false;

            StateHasChanged();
        }
    }

    private async Task<List<TagOption>> LoadChildOptions(TagOption parentOption)
    {
        var options = new List<TagOption>();

        if (parentOption.NodeId.HasValue)
        {
            var children = TagGraphService.GetChildren(parentOption.NodeId.Value);

            foreach (var child in children)
            {
                var hasChildren = TagGraphService.GetChildren(child.Id).Any();
                var groupIcon = activeGroup?.Icon; // Pass current group icon

                options.Add(SpriteResolver.ResolveTag(child.Text, child.Id, hasChildren, groupIcon));
            }
        }

        return options.OrderBy(o => o.Display).ToList();
    }

    private async Task LoadSourceOptions(string panelKey, SourceConfig source)
    {
        try
        {
            var options = new List<TagOption>();
            var sourceKey = GetSourceKey(panelKey, source);
            var groupIcon = activeGroup?.Icon;

            if (source.Type == SourceType.DbQuery && source.DbPath != null)
            {
                var dbOptions = await LoadDbQueryOptions(source.DbPath, groupIcon);
                options.AddRange(dbOptions);
            }
            else if (source.Type == SourceType.FileGlob && !string.IsNullOrEmpty(source.FileGlob))
            {
                var fileOptions = await SpriteResolver.DiscoverByFileGlobAsync(source.FileGlob);
                // Add group icon to file options
                foreach (var option in fileOptions)
                {
                    option.GroupIcon = groupIcon;
                }
                options.AddRange(fileOptions);
            }

            // Sort options
            options = options.OrderBy(o => o.Display).ToList();

            // Initialize navigation state for this source
            if (!navigationState.ContainsKey(sourceKey))
                navigationState[sourceKey] = new List<NavigationBreadcrumb>();

            // Add root level to navigation
            navigationState[sourceKey].Add(new NavigationBreadcrumb
            {
                Display = source.Title ?? "Root",
                Options = options
            });

            // Cache the results
            if (!sourceOptionsCache.ContainsKey(panelKey))
                sourceOptionsCache[panelKey] = new Dictionary<SourceConfig, List<TagOption>>();

            sourceOptionsCache[panelKey][source] = options;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading source options: {ex.Message}");
        }
    }

    private async Task<List<TagOption>> LoadDbQueryOptions(List<string> dbPath, string? groupIcon = null)
    {
        var options = new List<TagOption>();

        try
        {
            // Navigate to target node
            Node? currentNode = null;

            for (int i = 0; i < dbPath.Count; i++)
            {
                if (currentNode == null)
                {
                    var searchResults = TagGraphService.Search(dbPath[i], 10);
                    currentNode = searchResults
                        .Select(r => TagGraphService.GetNodeById(r.Id))
                        .FirstOrDefault(n => n != null &&
                                       n.Text.Equals(dbPath[i], StringComparison.OrdinalIgnoreCase));
                }
                else
                {
                    var children = TagGraphService.GetChildren(currentNode.Id);
                    currentNode = children.FirstOrDefault(c =>
                        c.Text.Equals(dbPath[i], StringComparison.OrdinalIgnoreCase) ||
                        c.Text.Replace(" ", "_").Equals(dbPath[i], StringComparison.OrdinalIgnoreCase) ||
                        c.Text.Replace("_", " ").Equals(dbPath[i], StringComparison.OrdinalIgnoreCase));
                }

                if (currentNode == null) break;
            }

            if (currentNode != null)
            {
                var children = TagGraphService.GetChildren(currentNode.Id);

                foreach (var child in children)
                {
                    // Check if this child has its own children
                    var hasChildren = TagGraphService.GetChildren(child.Id).Any();

                    options.Add(SpriteResolver.ResolveTag(child.Text, child.Id, hasChildren, groupIcon));
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading DB query for path {string.Join("/", dbPath)}: {ex.Message}");
        }

        return options;
    }

    private void SelectOption(PanelConfig panel, TagOption option)
    {
        // Determine if we should use multi-selection based on panel mode or source override
        var sourceKey = GetSourceKeyForPanel(panel, option);
        var effectiveSelectionMode = IsMultiSelectMode(sourceKey) ?
            Models.CharacterDesigner.SelectionMode.Multi :
            panel.SelectionMode;

        BuildState.ToggleSelection(
            panel.Key,
            panel.PromptOrderWeight,
            effectiveSelectionMode,
            option
        );
    }

    private string GetSourceKeyForPanel(PanelConfig panel, TagOption option)
    {
        // Find which source this option came from (simplified approach)
        foreach (var source in panel.Sources)
        {
            var sourceKey = GetSourceKey(panel.Key, source);
            var breadcrumbs = GetNavigationBreadcrumbs(sourceKey);

            if (breadcrumbs.Any(b => b.Options.Any(o => o.CanonicalTag == option.CanonicalTag)))
            {
                return sourceKey;
            }
        }

        // Fallback to first source
        return panel.Sources.Any() ? GetSourceKey(panel.Key, panel.Sources.First()) : string.Empty;
    }

    private async Task CopyPrompt()
    {
        var prompt = BuildState.BuildPrompt();
        if (!string.IsNullOrWhiteSpace(prompt))
        {
            await JSRuntime.InvokeVoidAsync("copyToClipboard", prompt);
        }
    }

    private void ResetSelections()
    {
        BuildState.Reset();
    }
}