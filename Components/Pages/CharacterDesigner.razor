@page "/character"
@using TagbooruQuest.Models.CharacterDesigner
@using TagbooruQuest.Services.CharacterDesigner
@using TagbooruQuest.Services.ComfyUI
@using TagbooruQuest.Components.Shared
@using TagbooruQuest.Data
@inject IDesignerRegistry DesignerRegistry
@inject ITagSpriteResolver SpriteResolver
@inject ICharacterBuildState BuildState
@inject TagbooruQuest.Data.TagGraphService TagGraphService
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>Character Designer</PageTitle>

<div class="character-builder @(isLivePreviewCollapsed ? "" : "with-live-preview")">
    <!-- Header with Title and Stats -->
    <div class="builder-header">
        <h1 class="builder-title">‚öîÔ∏è Character Builder</h1>
        <div class="character-stats">
            <span class="stat-icon">üéØ</span>
            <span class="stat-value">@BuildState.GetAllSelections().Count</span>
        </div>
    </div>

    <!-- Category Tabs -->
    <div class="category-tabs">
        @foreach (var group in DesignerRegistry.Config.Groups)
        {
            var selectionCount = GetGroupSelectionCount(group.Key);
            var backgroundStyle = !string.IsNullOrEmpty(group.BackgroundImage) ? $"background-image: url('{group.BackgroundImage}')" : "";
            <button class="category-tab @(activeGroupKey == group.Key ? "active" : "")"
                    style="@backgroundStyle"
                    @onclick="() => SetActiveGroup(group.Key)">
                <div class="tab-icon">@group.Icon</div>
                <div class="tab-title">@group.Title</div>
                @if (selectionCount > 0)
                {
                    <div class="selection-badge">@selectionCount</div>
                }
            </button>
        }
    </div>

    <!-- Builder Content -->
    <div class="builder-content">
        @if (activeGroup != null)
        {
            @foreach (var panel in activeGroup.Panels)
            {
                <div class="trait-panel">
                    <h3 class="panel-title">@panel.Title</h3>
                    <div class="panel-content">
                        @foreach (var source in panel.Sources)
                    {
                        var sourceKey = GetSourceKey(panel.Key, source);
                        var isExpanded = IsSourceExpanded(panel.Key, source);

                        <div class="source-section">
                            <div class="source-header">
                                <h4 class="source-title" @onclick="() => ToggleSourceExpanded(panel.Key, source)">@(source.Title ?? "Options")</h4>
                                <div class="source-controls">
                                    <button class="multi-select-toggle @(IsMultiSelectMode(sourceKey) ? "active" : "")"
                                            @onclick="() => ToggleMultiSelectMode(sourceKey)">
                                        Multi
                                    </button>
                                    <button class="expand-btn @(isExpanded ? "expanded" : "")" @onclick="() => ToggleSourceExpanded(panel.Key, source)">
                                    </button>
                                </div>
                            </div>

                            @if (isExpanded)
                            {
                                var sourceOptions = GetSourceOptions(panel.Key, source);
                                <div class="tag-grid">
                                    @if (sourceOptions?.Any() == true)
                                    {
                                        @foreach (var option in sourceOptions)
                                        {
                                            var isSelected = BuildState.GetSelections(panel.Key)
                                                .Any(s => s.CanonicalTag == option.CanonicalTag);
                                            var childrenKey = GetSanitizedChildrenKey(sourceKey, option);
                                            var childrenExpanded = IsChildrenExpanded(childrenKey);

                                            <div class="tag-item-container">
                                                <!-- Main Tag Tile -->
                                                <div class="tag-tile @(isSelected ? "selected" : "") @(option.HasChildren ? "has-children" : "")"
                                                     @onclick="() => HandleTagClick(panel, option, sourceKey)">
                                                    <img src="@option.ImageUrl" alt="@option.Display" class="tile-image" loading="lazy" onerror="this.src='img/sprites/others.jpg'" />
                                                    <div class="tile-label">@option.Display</div>
                                                    @if (option.HasChildren)
                                                    {
                                                        <div class="children-indicator">@(childrenExpanded ? "‚àí" : "+")</div>
                                                    }
                                                </div>

                                                <!-- Children Dropdown (floating overlay) -->
                                                @if (option.HasChildren)
                                                {
                                                    var childOptions = GetChildOptions(childrenKey);
                                                    <div class="children-dropdown @(childrenExpanded ? "show" : "hide")" id="dropdown-@childrenKey">
                                                        <div class="dropdown-arrow"></div>
                                                        @if (childOptions?.Any() == true)
                                                        {
                                                            @foreach (var child in childOptions)
                                                            {
                                                                var childSelected = BuildState.GetSelections(panel.Key)
                                                                    .Any(s => s.CanonicalTag == child.CanonicalTag);
                                                                var childChildrenKey = SanitizeForHtmlId($"{childrenKey}_{child.CanonicalTag}");
                                                                var childChildrenExpanded = IsChildrenExpanded(childChildrenKey);

                                                                <div class="child-tag-container">
                                                                    <div class="child-tag-tile @(childSelected ? "selected" : "") @(child.HasChildren ? "has-children" : "")"
                                                                         @onclick="() => HandleTagClick(panel, child, childrenKey)">
                                                                        <img src="@child.ImageUrl" alt="@child.Display" class="child-tile-image" loading="lazy" onerror="this.src='img/sprites/others.jpg'" />
                                                                        <div class="child-tile-label">@child.Display</div>
                                                                        @if (child.HasChildren)
                                                                        {
                                                                            <div class="child-children-indicator">@(childChildrenExpanded ? "‚àí" : "+")</div>
                                                                        }
                                                                    </div>

                                                                    <!-- Nested Children Dropdown (recursive) -->
                                                                    @if (child.HasChildren)
                                                                    {
                                                                        var childChildOptions = GetChildOptions(childChildrenKey);
                                                                        <div class="nested-children-dropdown @(childChildrenExpanded ? "show" : "hide")" id="dropdown-@childChildrenKey">
                                                                            <div class="dropdown-arrow"></div>
                                                                            @if (childChildOptions?.Any() == true)
                                                                            {
                                                                                @foreach (var grandchild in childChildOptions)
                                                                                {
                                                                                    @RenderNestedChild(panel, grandchild, sourceKey, childChildrenKey, 2)
                                                                                }
                                                                            }
                                                                            else
                                                                            {
                                                                                <div class="loading">Loading children...</div>
                                                                            }
                                                                        </div>
                                                                    }
                                                                </div>
                                                            }
                                                        }
                                                        else
                                                        {
                                                            <div class="loading">Loading children...</div>
                                                        }
                                                    </div>
                                                }
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <div class="loading">Loading options...</div>
                                    }
                                </div>
                            }
                        </div>
                    }
                    </div>
                </div>
            }
        }
    </div>

    <!-- Character Summary -->
    <div class="character-summary">
        <h3 class="summary-title">üé≠ Character Prompt</h3>
        <div class="prompt-preview">
            @{
                var allSelections = BuildState.GetAllSelections();
            }
            @if (allSelections.Any())
            {
                @foreach (var (selection, panelKey) in GetSelectionsWithPanelKeys())
                {
                    <div class="prompt-chip" data-panel-key="@panelKey" data-tag="@selection.CanonicalTag"
                         @onclick="() => NavigateToTag(panelKey, selection.CanonicalTag)">
                        <img src="@selection.ImageUrl" alt="@selection.Display" class="chip-image" loading="lazy" onerror="this.src='img/sprites/others.jpg'" />
                        <span class="chip-text">@selection.Display</span>
                        <button class="chip-remove" @onclick="() => RemoveSelection(panelKey, selection.CanonicalTag)"
                                @onclick:stopPropagation="true" title="Remove @selection.Display">√ó</button>
                    </div>
                }
            }
            else
            {
                <div class="empty-prompt">Start building your character by selecting traits above!</div>
            }
        </div>
        <div class="summary-actions">
            <button class="action-btn primary" @onclick="CopyPrompt">üìã Copy Prompt</button>
            <button class="action-btn secondary" @onclick="ResetSelections">üóëÔ∏è Reset All</button>
        </div>
    </div>
</div>

<!-- ComfyUI Live Preview Panel -->
<ComfyUILivePreview IsCollapsed="isLivePreviewCollapsed" IsCollapsedChanged="(bool value) => isLivePreviewCollapsed = value" />

@code {
    private string activeGroupKey = "hair";
    private GroupConfig? activeGroup;
    private Dictionary<string, Dictionary<SourceConfig, bool>> expandedSources = new();
    private Dictionary<string, Dictionary<SourceConfig, List<TagOption>>> sourceOptionsCache = new();
    private Dictionary<string, List<TagOption>> childOptionsCache = new();
    private Dictionary<string, bool> multiSelectMode = new();
    private Dictionary<string, bool> childrenExpanded = new();
    private bool isLivePreviewCollapsed = false;

    protected override async Task OnInitializedAsync()
    {
        activeGroup = DesignerRegistry.GetGroup(activeGroupKey);
        BuildState.OnStateChanged += StateHasChanged;

        // Disabled aggressive cleanup to prevent crashes
        // try
        // {
        //     await JSRuntime.InvokeVoidAsync("onBlazorStateChange");
        // }
        // catch (Exception ex)
        // {
        //     Console.WriteLine($"Error calling onBlazorStateChange: {ex.Message}");
        // }

        // Initialize default expansion states from configuration
        InitializeDefaultExpansionStates();

        // Validate configuration in background
        _ = Task.Run(async () =>
        {
            try
            {
                await DesignerRegistry.ValidateConfigurationAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Configuration validation failed: {ex.Message}");
            }
        });

        // Position badges after component renders
        _ = Task.Run(async () =>
        {
            await Task.Delay(100); // Let DOM settle
            try
            {
                await JSRuntime.InvokeVoidAsync("positionBadges");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Badge positioning failed: {ex.Message}");
            }
        });

        // Set up JavaScript callback for dropdown close events
        var dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("setupDropdownCallbacks", dotNetRef);
    }

    public void Dispose()
    {
        BuildState.OnStateChanged -= StateHasChanged;
    }

    private void InitializeDefaultExpansionStates()
    {
        foreach (var group in DesignerRegistry.Config.Groups)
        {
            foreach (var panel in group.Panels)
            {
                if (!expandedSources.ContainsKey(panel.Key))
                    expandedSources[panel.Key] = new Dictionary<SourceConfig, bool>();

                foreach (var source in panel.Sources)
                {
                    expandedSources[panel.Key][source] = source.ExpandedByDefault;

                    // Pre-load options for expanded sources
                    if (source.ExpandedByDefault)
                    {
                        _ = LoadSourceOptionsAndNotify(panel.Key, source);
                    }
                }
            }
        }
    }

    private async Task LoadSourceOptionsAndNotify(string panelKey, SourceConfig source)
    {
        await LoadSourceOptions(panelKey, source);
        // Notify the UI that loading is complete
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public void OnDropdownClosed(string childrenKey)
    {
        Console.WriteLine($"Dropdown closed via click outside: {childrenKey}");

        // Update the Blazor state to match the JavaScript state
        if (childrenExpanded.ContainsKey(childrenKey) && childrenExpanded[childrenKey])
        {
            childrenExpanded[childrenKey] = false;
            StateHasChanged();
        }
    }

    private void SetActiveGroup(string groupKey)
    {
        activeGroupKey = groupKey;
        activeGroup = DesignerRegistry.GetGroup(groupKey);

        // Cleanup disabled - let Blazor handle component lifecycle naturally

        StateHasChanged();

        // Reposition badges after state change
        _ = Task.Run(async () =>
        {
            await Task.Delay(50);
            try
            {
                await JSRuntime.InvokeVoidAsync("positionBadges");
            }
            catch { }
        });
    }

    private int GetGroupSelectionCount(string groupKey)
    {
        var group = DesignerRegistry.GetGroup(groupKey);
        if (group == null) return 0;

        return group.Panels.Sum(panel => BuildState.GetSelections(panel.Key).Count);
    }

    private async Task ToggleSourceExpanded(string panelKey, SourceConfig source)
    {
        if (!expandedSources.ContainsKey(panelKey))
            expandedSources[panelKey] = new Dictionary<SourceConfig, bool>();

        var isExpanded = expandedSources[panelKey].ContainsKey(source) && expandedSources[panelKey][source];
        expandedSources[panelKey][source] = !isExpanded;

        if (!isExpanded && !HasCachedOptions(panelKey, source))
        {
            await LoadSourceOptions(panelKey, source);
        }

        StateHasChanged();
    }

    private bool IsSourceExpanded(string panelKey, SourceConfig source)
    {
        return expandedSources.ContainsKey(panelKey) &&
               expandedSources[panelKey].ContainsKey(source) &&
               expandedSources[panelKey][source];
    }

    private bool HasCachedOptions(string panelKey, SourceConfig source)
    {
        return sourceOptionsCache.ContainsKey(panelKey) &&
               sourceOptionsCache[panelKey].ContainsKey(source);
    }

    private string GetSourceKey(string panelKey, SourceConfig source)
    {
        return $"{panelKey}_{source.GetHashCode()}";
    }

    private List<TagOption>? GetSourceOptions(string panelKey, SourceConfig source)
    {
        if (sourceOptionsCache.ContainsKey(panelKey) && sourceOptionsCache[panelKey].ContainsKey(source))
        {
            return sourceOptionsCache[panelKey][source];
        }
        return null;
    }

    private List<TagOption>? GetChildOptions(string childrenKey)
    {
        return childOptionsCache.ContainsKey(childrenKey) ? childOptionsCache[childrenKey] : null;
    }

    private bool IsChildrenExpanded(string childrenKey)
    {
        return childrenExpanded.ContainsKey(childrenKey) && childrenExpanded[childrenKey];
    }

    private bool IsMultiSelectMode(string sourceKey)
    {
        return multiSelectMode.ContainsKey(sourceKey) && multiSelectMode[sourceKey];
    }

    private void ToggleMultiSelectMode(string sourceKey)
    {
        multiSelectMode[sourceKey] = !IsMultiSelectMode(sourceKey);
        StateHasChanged();
    }

    private async Task HandleTagClick(PanelConfig panel, TagOption option, string sourceKey)
    {
        if (option.HasChildren)
        {
            var childrenKey = GetSanitizedChildrenKey(sourceKey, option);
            await ToggleChildren(childrenKey, option);
        }
        else
        {
            SelectOption(panel, option);
        }
    }

    private async Task ToggleChildren(string childrenKey, TagOption parentOption)
    {
        Console.WriteLine($"ToggleChildren called with childrenKey: '{childrenKey}'");
        var isExpanded = IsChildrenExpanded(childrenKey);
        childrenExpanded[childrenKey] = !isExpanded;

        if (!isExpanded && !childOptionsCache.ContainsKey(childrenKey))
        {
            // Load children on first expand
            try
            {
                var childOptions = await LoadChildOptions(parentOption);
                childOptionsCache[childrenKey] = childOptions;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading children: {ex.Message}");
            }
        }

        StateHasChanged();

        // Position the dropdown after state update
        if (!isExpanded) // Now expanded
        {
            await Task.Delay(50); // Let DOM update completely
            var dropdownId = $"dropdown-{childrenKey}";
            Console.WriteLine($"Calling positionDropdown with ID: '{dropdownId}'");
            await JSRuntime.InvokeVoidAsync("positionDropdown", dropdownId);
        }
        else // Now collapsed
        {
            // Explicitly hide the dropdown
            var dropdownId = $"dropdown-{childrenKey}";
            Console.WriteLine($"Calling hideDropdown with ID: '{dropdownId}'");
            await JSRuntime.InvokeVoidAsync("hideDropdown", dropdownId);
        }

        // Let the periodic cleanup handle any edge cases
        // Removed manual cleanup to prevent interference with reopening
    }

    private async Task<List<TagOption>> LoadChildOptions(TagOption parentOption)
    {
        var options = new List<TagOption>();

        if (parentOption.NodeId.HasValue)
        {
            var children = TagGraphService.GetChildren(parentOption.NodeId.Value);

            foreach (var child in children)
            {
                var hasChildren = TagGraphService.GetChildren(child.Id).Any();
                var groupIcon = activeGroup?.Icon;

                options.Add(SpriteResolver.ResolveTag(child.Text, child.Id, hasChildren, groupIcon));
            }
        }

        return options.OrderBy(o => o.Display).ToList();
    }

    private async Task LoadSourceOptions(string panelKey, SourceConfig source)
    {
        try
        {
            var options = new List<TagOption>();
            var sourceKey = GetSourceKey(panelKey, source);
            var groupIcon = activeGroup?.Icon;

            if (source.Type == SourceType.DbQuery && source.DbPath != null)
            {
                var dbOptions = await LoadDbQueryOptions(source.DbPath, groupIcon);
                options.AddRange(dbOptions);
            }
            else if (source.Type == SourceType.FileGlob && !string.IsNullOrEmpty(source.FileGlob))
            {
                var fileOptions = await SpriteResolver.DiscoverByFileGlobAsync(source.FileGlob);
                foreach (var option in fileOptions)
                {
                    option.GroupIcon = groupIcon;
                }
                options.AddRange(fileOptions);
            }

            options = options.OrderBy(o => o.Display).ToList();

            if (!sourceOptionsCache.ContainsKey(panelKey))
                sourceOptionsCache[panelKey] = new Dictionary<SourceConfig, List<TagOption>>();

            sourceOptionsCache[panelKey][source] = options;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading source options: {ex.Message}");
        }
    }

    private async Task<List<TagOption>> LoadDbQueryOptions(List<string> dbPath, string? groupIcon = null)
    {
        var options = new List<TagOption>();

        try
        {
            Node? currentNode = null;

            for (int i = 0; i < dbPath.Count; i++)
            {
                if (currentNode == null)
                {
                    var searchResults = TagGraphService.Search(dbPath[i], 100);
                    var allCandidates = searchResults
                        .Select(r => TagGraphService.GetNodeById(r.Id))
                        .Where(n => n != null &&
                                   n.Text.Equals(dbPath[i], StringComparison.OrdinalIgnoreCase))
                        .ToList();

                    // ALWAYS prefer nodes that have children over leaf nodes
                    var nodesWithChildren = allCandidates.Where(c => TagGraphService.GetChildren(c.Id).Any()).ToList();
                    currentNode = nodesWithChildren.Any() ? nodesWithChildren.First() : allCandidates.FirstOrDefault();
                }
                else
                {
                    var children = TagGraphService.GetChildren(currentNode.Id);
                    var allCandidates = children.Where(c =>
                        c.Text.Equals(dbPath[i], StringComparison.OrdinalIgnoreCase) ||
                        c.Text.Replace(" ", "_").Equals(dbPath[i], StringComparison.OrdinalIgnoreCase) ||
                        c.Text.Replace("_", " ").Equals(dbPath[i], StringComparison.OrdinalIgnoreCase)).ToList();

                    // ALWAYS prefer nodes that have children over leaf nodes
                    var nodesWithChildren = allCandidates.Where(c => TagGraphService.GetChildren(c.Id).Any()).ToList();
                    currentNode = nodesWithChildren.Any() ? nodesWithChildren.First() : allCandidates.FirstOrDefault();
                }

                if (currentNode == null) break;
            }

            if (currentNode != null)
            {
                var children = TagGraphService.GetChildren(currentNode.Id);

                foreach (var child in children)
                {
                    var hasChildren = TagGraphService.GetChildren(child.Id).Any();
                    options.Add(SpriteResolver.ResolveTag(child.Text, child.Id, hasChildren, groupIcon));
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading DB query for path {string.Join("/", dbPath)}: {ex.Message}");
        }

        return options;
    }

    private void SelectOption(PanelConfig panel, TagOption option)
    {
        var sourceKey = GetSourceKeyForPanel(panel, option);
        var effectiveSelectionMode = IsMultiSelectMode(sourceKey) ?
            Models.CharacterDesigner.SelectionMode.Multi :
            panel.SelectionMode;

        BuildState.ToggleSelection(
            panel.Key,
            panel.PromptOrderWeight,
            effectiveSelectionMode,
            option
        );
    }

    private string GetSourceKeyForPanel(PanelConfig panel, TagOption option)
    {
        foreach (var source in panel.Sources)
        {
            var sourceKey = GetSourceKey(panel.Key, source);
            var sourceOptions = GetSourceOptions(panel.Key, source);

            if (sourceOptions?.Any(o => o.CanonicalTag == option.CanonicalTag) == true)
            {
                return sourceKey;
            }
        }

        return panel.Sources.Any() ? GetSourceKey(panel.Key, panel.Sources.First()) : string.Empty;
    }

    private string SanitizeForHtmlId(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        // Replace spaces and special characters with underscores
        // Keep alphanumeric, hyphens, and underscores only
        return System.Text.RegularExpressions.Regex.Replace(input, @"[^a-zA-Z0-9\-_]", "_");
    }

    private string GetSanitizedChildrenKey(string sourceKey, TagOption option)
    {
        var originalKey = $"{sourceKey}_{option.CanonicalTag}";
        var sanitizedKey = SanitizeForHtmlId(originalKey);
        Console.WriteLine($"GetSanitizedChildrenKey: '{originalKey}' -> '{sanitizedKey}'");
        return sanitizedKey;
    }

    private async Task CopyPrompt()
    {
        var prompt = BuildState.BuildPrompt();
        if (!string.IsNullOrWhiteSpace(prompt))
        {
            await JSRuntime.InvokeVoidAsync("copyToClipboard", prompt);
        }
    }

    private void ResetSelections()
    {
        BuildState.Reset();
    }

    private void RemoveSelection(string panelKey, string canonicalTag)
    {
        BuildState.RemoveSelection(panelKey, canonicalTag);
    }

    private List<(TagOption selection, string panelKey)> GetSelectionsWithPanelKeys()
    {
        var result = new List<(TagOption, string)>();

        foreach (var group in DesignerRegistry.Config.Groups)
        {
            foreach (var panel in group.Panels)
            {
                var selections = BuildState.GetSelections(panel.Key);
                foreach (var selection in selections)
                {
                    result.Add((selection, panel.Key));
                }
            }
        }

        // Remove duplicates based on CanonicalTag, keeping the first occurrence based on panel order
        var deduplicatedResult = result
            .OrderBy(x => GetPanelPromptOrderWeight(x.Item2))
            .GroupBy(x => x.Item1.CanonicalTag)
            .Select(g => g.First())
            .ToList();

        return deduplicatedResult;
    }

    private int GetPanelPromptOrderWeight(string panelKey)
    {
        foreach (var group in DesignerRegistry.Config.Groups)
        {
            foreach (var panel in group.Panels)
            {
                if (panel.Key == panelKey)
                    return panel.PromptOrderWeight;
            }
        }
        return 0;
    }

    private async Task NavigateToTag(string panelKey, string canonicalTag)
    {
        // Find the group that contains this panel
        var targetGroup = DesignerRegistry.Config.Groups
            .FirstOrDefault(g => g.Panels.Any(p => p.Key == panelKey));

        if (targetGroup != null)
        {
            // Switch to the correct group tab
            SetActiveGroup(targetGroup.Key);

            // Wait for the UI to update
            await Task.Delay(100);

            // Scroll to the tag (we'll implement this with JavaScript)
            await JSRuntime.InvokeVoidAsync("scrollToTag", canonicalTag);
        }
    }

    private RenderFragment RenderNestedChild(PanelConfig panel, TagOption child, string sourceKey, string parentKey, int depth) => builder =>
    {
        var childSelected = BuildState.GetSelections(panel.Key).Any(s => s.CanonicalTag == child.CanonicalTag);
        var nestedChildrenKey = SanitizeForHtmlId($"{parentKey}_{child.CanonicalTag}");
        var nestedChildrenExpanded = IsChildrenExpanded(nestedChildrenKey);
        var depthClass = $"nested-depth-{Math.Min(depth, 5)}"; // Limit visual depth to 5 levels

        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "class", "nested-child-container");

        // Render the nested child tile
        builder.OpenElement(2, "div");
        builder.AddAttribute(3, "class", $"nested-child-tile {depthClass} {(childSelected ? "selected" : "")} {(child.HasChildren ? "has-children" : "")}");
        builder.AddAttribute(4, "onclick", EventCallback.Factory.Create(this, () => {
            Console.WriteLine($"RenderNestedChild: HandleTagClick called with parentKey: '{parentKey}', child: '{child.CanonicalTag}'");
            HandleTagClick(panel, child, parentKey);
        }));

        // Child image
        builder.OpenElement(5, "img");
        builder.AddAttribute(6, "src", child.ImageUrl);
        builder.AddAttribute(7, "alt", child.Display);
        builder.AddAttribute(8, "class", "nested-child-image");
        builder.AddAttribute(9, "loading", "lazy");
        builder.AddAttribute(10, "onerror", "this.src='img/sprites/others.jpg'");
        builder.CloseElement(); // img

        // Child label
        builder.OpenElement(11, "div");
        builder.AddAttribute(12, "class", "nested-child-label");
        builder.AddContent(13, child.Display);
        builder.CloseElement(); // label div

        // Children indicator if has children
        if (child.HasChildren)
        {
            builder.OpenElement(14, "div");
            builder.AddAttribute(15, "class", "nested-children-indicator");
            builder.AddContent(16, nestedChildrenExpanded ? "‚àí" : "+");
            builder.CloseElement(); // indicator div
        }

        builder.CloseElement(); // tile div

        // Recursive nested dropdown
        if (child.HasChildren && depth < 10) // Prevent infinite recursion, max 10 levels
        {
            var nestedChildOptions = GetChildOptions(nestedChildrenKey);

            builder.OpenElement(17, "div");
            builder.AddAttribute(18, "class", $"recursive-children-dropdown {depthClass} {(nestedChildrenExpanded ? "show" : "hide")}");
            builder.AddAttribute(19, "id", $"dropdown-{nestedChildrenKey}");

            // Dropdown arrow
            builder.OpenElement(20, "div");
            builder.AddAttribute(21, "class", "dropdown-arrow");
            builder.CloseElement();

            if (nestedChildOptions?.Any() == true)
            {
                foreach (var grandchild in nestedChildOptions)
                {
                    builder.AddContent(22, RenderNestedChild(panel, grandchild, sourceKey, nestedChildrenKey, depth + 1));
                }
            }
            else
            {
                builder.OpenElement(23, "div");
                builder.AddAttribute(24, "class", "loading");
                builder.AddContent(25, "Loading children...");
                builder.CloseElement();
            }

            builder.CloseElement(); // dropdown div
        }

        builder.CloseElement(); // container div
    };
}